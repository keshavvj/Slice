datasource db {
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  auth0Id   String   @unique
  email     String?
  handle    String?  @unique
  displayName String?
  createdAt DateTime @default(now())

  // Relations
  sentRequests     FriendRequest[] @relation("SentRequests")
  receivedRequests FriendRequest[] @relation("ReceivedRequests")
  
  friendshipsA     Friendship[]    @relation("FriendshipUserA")
  friendshipsB     Friendship[]    @relation("FriendshipUserB")

  invitesCreated   FriendInvite[]  @relation("CreatedInvites")

  // Goals Relations
  goalMemberships  GoalMember[]
  contributions    Contribution[]

  // Splits Relations
  splitMemberships SplitMember[]
  sentSplits       SplitRequest[]  @relation("SentSplits")
  receivedSplits   SplitRequest[]  @relation("ReceivedSplits")

  // Plaid Relations
  bankConnections  BankConnection[]
  bankAccounts     BankAccount[]
  transactions     Transaction[]
}

model FriendRequest {
  id        String   @id @default(cuid())
  fromUserId String
  toUserId   String
  status    String   @default("pending") // pending, accepted, declined, canceled
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  fromUser User @relation("SentRequests", fields: [fromUserId], references: [id])
  toUser   User @relation("ReceivedRequests", fields: [toUserId], references: [id])

  @@unique([fromUserId, toUserId])
  @@index([toUserId])
  @@index([status])
}

model Friendship {
  id        String   @id @default(cuid())
  userAId   String
  userBId   String
  createdAt DateTime @default(now())

  userA User @relation("FriendshipUserA", fields: [userAId], references: [id])
  userB User @relation("FriendshipUserB", fields: [userBId], references: [id])

  @@unique([userAId, userBId])
}

model FriendInvite {
  id             String   @id @default(cuid())
  code           String   @unique
  createdByUserId String
  status         String   @default("active") // active, disabled
  expiresAt      DateTime?
  createdAt      DateTime @default(now())

  createdByUser User @relation("CreatedInvites", fields: [createdByUserId], references: [id])
}

// --- Goals System ---

model Goal {
  id            String   @id @default(cuid())
  title         String
  category      String   @default("General") // e.g., Travel, Gadget, Emergency
  targetAmount  Float
  currentAmount Float    @default(0)
  currency      String   @default("USD")
  targetDate    DateTime?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Recurring contributions handling
  recurringEnabled     Boolean @default(false)
  recurringAmount      Float?
  recurringFrequency   String? // weekly, biweekly, monthly
  recurringNextRun     DateTime?
  
  members       GoalMember[]
  contributions Contribution[]
}

model GoalMember {
  id        String   @id @default(cuid())
  goalId    String
  userId    String
  role      String   @default("MEMBER") // OWNER, MEMBER
  joinedAt  DateTime @default(now())

  goal      Goal     @relation(fields: [goalId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@unique([goalId, userId])
}

model Contribution {
  id        String   @id @default(cuid())
  goalId    String
  userId    String
  amount    Float
  note      String?
  type      String   @default("manual") // manual, recurring, roundup
  createdAt DateTime @default(now())

  goal      Goal     @relation(fields: [goalId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])
}

// --- Splits System ---

model SplitGroup {
  id        String   @id @default(cuid())
  name      String?  // Optional group name e.g. "Vegas Trip"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members   SplitMember[]
  requests  SplitRequest[]
}

model SplitMember {
  id           String   @id @default(cuid())
  splitGroupId String
  userId       String
  joinedAt     DateTime @default(now())

  group        SplitGroup @relation(fields: [splitGroupId], references: [id], onDelete: Cascade)
  user         User       @relation(fields: [userId], references: [id])

  @@unique([splitGroupId, userId])
}

model SplitRequest {
  id             String   @id @default(cuid())
  splitGroupId   String?  // Optional, can be standalone
  fromUserId     String   // The person who paid / requests money
  toUserId       String   // The person who owes
  amount         Float
  description    String?
  status         String   @default("pending") // pending, paid, declined
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  group          SplitGroup? @relation(fields: [splitGroupId], references: [id])
  fromUser       User        @relation("SentSplits", fields: [fromUserId], references: [id])
  toUser         User        @relation("ReceivedSplits", fields: [toUserId], references: [id])

  @@index([fromUserId])

  @@index([toUserId])
  @@index([status])
}

// --- Plaid Banking Integration ---

model BankConnection {
  id                  String   @id @default(cuid())
  userId              String
  plaidItemId         String   @unique
  institutionId       String?
  institutionName     String?

  // Encrypted access token
  accessTokenCiphertext String
  accessTokenIv         String
  accessTokenTag        String
  
  status              String   @default("active") // active, error, disconnected
  lastSyncAt          DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  accounts            BankAccount[]
  transactionCursor   TransactionCursor?
  
  @@index([userId])
}

model BankAccount {
  id                  String   @id @default(cuid())
  userId              String
  bankConnectionId    String

  plaidAccountId      String   @unique
  name                String
  mask                String?
  type                String   // depository, credit, loan, etc.
  subtype             String?  // checking, savings, etc.

  currentBalance      Float?
  availableBalance    Float?
  isoCurrencyCode     String?

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user                User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  connection          BankConnection @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
  transactions        Transaction[]

  @@index([userId])
  @@index([bankConnectionId])
}

model Transaction {
  id                  String   @id @default(cuid())
  userId              String
  bankAccountId       String

  plaidTransactionId  String   @unique
  name                String
  merchantName        String?
  amount              Float    // Plaid: postive = pending spent, negative = refund/deposit.
  isoCurrencyCode     String?

  date                DateTime
  authorizedDate      DateTime?

  pending             Boolean  @default(false)
  paymentChannel      String?

  categoryPrimary     String?
  categoryDetailed    String?

  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user                User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  account             BankAccount @relation(fields: [bankAccountId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([bankAccountId])
  @@index([date])
}

model TransactionCursor {
  id                  String   @id @default(cuid())
  bankConnectionId    String   @unique
  cursor              String?
  lastSyncAt          DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  connection          BankConnection @relation(fields: [bankConnectionId], references: [id], onDelete: Cascade)
}
